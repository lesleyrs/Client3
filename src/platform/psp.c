#ifdef __PSP__
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#include <pspctrl.h>
#include <pspdisplay.h>
#include <pspkernel.h>
#include <pspnet.h>
#include <pspnet_apctl.h>
#include <pspnet_inet.h>
#include <pspnet_resolver.h>
#include <psppower.h>
#include <psprtc.h>
#include <pspsdk.h>
#include <psputility.h>

#include "../client.h"
#include "../custom.h"
#include "../gameshell.h"
#include "../inputtracking.h"
#include "../pixmap.h"
#include "../platform.h"

extern ClientData _Client;
extern InputTracking _InputTracking;
extern Custom _Custom;

PSP_MODULE_INFO("client", 0, 2, 225);
// PSP_MAIN_THREAD_ATTR(THREAD_ATTR_USER | THREAD_ATTR_VFPU);
PSP_MAIN_THREAD_ATTR(PSP_THREAD_ATTR_USER);

#define VRAM_STRIDE 512
#define INITIAL_X_OFFSET (SCREEN_FB_WIDTH - SCREEN_WIDTH) / 2
#define INITIAL_Y_OFFSET (SCREEN_FB_HEIGHT - SCREEN_HEIGHT) / 2

static uint16_t *fb = (uint16_t *)0x04000000; // vram start
static SceCtrlData pad, last_pad;
static int cursor_x = SCREEN_FB_WIDTH / 2;
static int cursor_y = SCREEN_FB_HEIGHT / 2;
static int screen_offset_x = INITIAL_X_OFFSET;
static int screen_offset_y = INITIAL_Y_OFFSET;

#define CURSOR_W 12
#define CURSOR_H 18
static const unsigned char cursor[] = {
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x01, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

int get_free_mem(void) {
    return pspSdkTotalFreeUserMemSize();
}

int exit_callback(int arg1, int arg2, void *common) {
    sceKernelExitGame();
    return 0;
}

/* Callback thread */
int CallbackThread(SceSize args, void *argp) {
    int cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
    sceKernelRegisterExitCallback(cbid);
    sceKernelSleepThreadCB();
    return 0;
}

/* Sets up the callback thread and returns its thread id */
int SetupCallbacks(void) {
    int thid = 0;
    thid = sceKernelCreateThread("update_thread", CallbackThread, 0x11, 0xFA0, 0, 0);
    if (thid >= 0) {
        sceKernelStartThread(thid, 0, 0);
    }
    return thid;
}

bool platform_init(void) {
    pspDebugScreenInit();
    // TODO is it ok to use kernel mode to use sceKernelGetModel?
    // if (sceKernelGetModel() == 0) {
    //     pspDebugScreenPrintf("Unsupported: PSP-1000 model detected, need 2000+ for extra RAM");
    //     return false;
    // }
    SetupCallbacks();
    scePowerSetClockFrequency(333, 333, 166);
    return true;
}

void platform_new(GameShell *shell) {
    (void)shell;
    sceDisplaySetFrameBuf(fb, VRAM_STRIDE, PSP_DISPLAY_PIXEL_FORMAT_565, PSP_DISPLAY_SETBUF_NEXTFRAME);
    sceCtrlSetSamplingCycle(0);
    sceCtrlSetSamplingMode(PSP_CTRL_MODE_ANALOG);
}

void platform_free(void) {
    sceNetApctlTerm();
    sceNetResolverTerm();
    sceNetInetTerm();
    sceNetTerm();
    sceUtilityUnloadNetModule(PSP_NET_MODULE_INET);
    sceUtilityUnloadNetModule(PSP_NET_MODULE_COMMON);
}
void platform_set_wave_volume(int wavevol) {
}
void platform_play_wave(int8_t *src, int length) {
}
void platform_set_midi_volume(float midivol) {
}
void platform_set_jingle(int8_t *src, int len) {
}
void platform_set_midi(const char *name, int crc, int len) {
}
void platform_stop_midi(void) {
}
void platform_poll_events(Client *c) {
    sceCtrlPeekBufferPositive(&pad, 1);

    if (!(last_pad.Buttons & PSP_CTRL_LEFT) && pad.Buttons & PSP_CTRL_LEFT) {
        key_pressed(c->shell, K_LEFT, -1);
    }

    if (!(last_pad.Buttons & PSP_CTRL_RIGHT) && pad.Buttons & PSP_CTRL_RIGHT) {
        key_pressed(c->shell, K_RIGHT, -1);
    }

    if (!(last_pad.Buttons & PSP_CTRL_UP) && pad.Buttons & PSP_CTRL_UP) {
        key_pressed(c->shell, K_UP, -1);
    }

    if (!(last_pad.Buttons & PSP_CTRL_DOWN) && pad.Buttons & PSP_CTRL_DOWN) {
        key_pressed(c->shell, K_DOWN, -1);
    }

    if (last_pad.Buttons & PSP_CTRL_LEFT && !(pad.Buttons & PSP_CTRL_LEFT)) {
        key_released(c->shell, K_LEFT, -1);
    }

    if (last_pad.Buttons & PSP_CTRL_RIGHT && !(pad.Buttons & PSP_CTRL_RIGHT)) {
        key_released(c->shell, K_RIGHT, -1);
    }

    if (last_pad.Buttons & PSP_CTRL_UP && !(pad.Buttons & PSP_CTRL_UP)) {
        key_released(c->shell, K_UP, -1);
    }

    if (last_pad.Buttons & PSP_CTRL_DOWN && !(pad.Buttons & PSP_CTRL_DOWN)) {
        key_released(c->shell, K_DOWN, -1);
    }

    bool ctrl_press = !(last_pad.Buttons & PSP_CTRL_TRIANGLE) && pad.Buttons & PSP_CTRL_TRIANGLE;
    bool ctrl_release = last_pad.Buttons & PSP_CTRL_TRIANGLE && !(pad.Buttons & PSP_CTRL_TRIANGLE);
    if (ctrl_press) {
        key_pressed(c->shell, K_CONTROL, -1);
    }

    if (ctrl_release) {
        key_released(c->shell, K_CONTROL, -1);
    }

    if (!(last_pad.Buttons & PSP_CTRL_SELECT) && pad.Buttons & PSP_CTRL_SELECT) {
        _Custom.showPerformance = !_Custom.showPerformance;
    }

    if (!(last_pad.Buttons & PSP_CTRL_SQUARE) && pad.Buttons & PSP_CTRL_SQUARE) {
        if (!c->ingame) {
            client_login(c, c->username, c->password, false);
        }
    }

    if (pad.Buttons & PSP_CTRL_LTRIGGER) {
        // viewport start
        screen_offset_x = -8;
        screen_offset_y = -11;
        c->redraw_background = true;
    }

    if (pad.Lx != 128 || pad.Ly != 128) {
        c->redraw_background = true;

#define CURSOR_SENSITIVITY 20
        // TODO allow changing cursor sensitivity, don't move cursor while panning
        if (pad.Buttons & PSP_CTRL_RTRIGGER) {
            screen_offset_x = MAX(SCREEN_FB_WIDTH - SCREEN_WIDTH, MIN(screen_offset_x - (pad.Lx - 128) / CURSOR_SENSITIVITY, 0));
            screen_offset_y = MAX(SCREEN_FB_HEIGHT - SCREEN_HEIGHT, MIN(screen_offset_y - (pad.Ly - 128) / CURSOR_SENSITIVITY, 0));
            // c->redraw_background = true;
        }

        cursor_x = MAX(0, MIN(cursor_x + (pad.Lx - 128) / CURSOR_SENSITIVITY, SCREEN_WIDTH - 1));
        cursor_y = MAX(0, MIN(cursor_y + (pad.Ly - 128) / CURSOR_SENSITIVITY, SCREEN_HEIGHT - 1));

        int x = cursor_x;
        int y = cursor_y;

        c->shell->idle_cycles = 0;
        c->shell->mouse_x = x;
        c->shell->mouse_y = y;

        if (_InputTracking.enabled) {
            inputtracking_mouse_moved(&_InputTracking, x, y);
        }
    }

    bool left_press = !(last_pad.Buttons & PSP_CTRL_CIRCLE) && pad.Buttons & PSP_CTRL_CIRCLE;
    bool right_press = !(last_pad.Buttons & PSP_CTRL_CROSS) && pad.Buttons & PSP_CTRL_CROSS;

    if (left_press || right_press) {
        int x = cursor_x;
        int y = cursor_y;

        c->shell->idle_cycles = 0;
        c->shell->mouse_click_x = x;
        c->shell->mouse_click_y = y;

        if (right_press) {
            c->shell->mouse_click_button = 2;
            c->shell->mouse_button = 2;
        } else {
            c->shell->mouse_click_button = 1;
            c->shell->mouse_button = 1;
        }

        if (_InputTracking.enabled) {
            inputtracking_mouse_pressed(&_InputTracking, x, y, right_press ? 1 : 0);
        }
    }

    bool left_release = last_pad.Buttons & PSP_CTRL_CIRCLE && !(pad.Buttons & PSP_CTRL_CIRCLE);
    bool right_release = last_pad.Buttons & PSP_CTRL_CROSS && !(pad.Buttons & PSP_CTRL_CROSS);

    if (left_release || right_release) {
        c->shell->idle_cycles = 0;
        c->shell->mouse_button = 0;

        if (_InputTracking.enabled) {
            inputtracking_mouse_released(&_InputTracking, right_release ? 1 : 0);
        }
    }

    last_pad = pad;
}
void platform_blit_surface(Surface *surface, int x, int y) {
    int relative_x = cursor_x + screen_offset_x;
    int relative_y = cursor_y + screen_offset_y;

    uint16_t *fb_ptr = (uint16_t *)fb + (y * VRAM_STRIDE + x);
    for (int row = 0; row < surface->h; row++) {
        int screen_y = y + row + screen_offset_y;
        if (screen_y < 0)
            continue;
        if (screen_y >= SCREEN_FB_HEIGHT)
            break;
        for (int col = 0; col < surface->w; col++) {
            int screen_x = x + col + screen_offset_x;
            if (screen_x < 0)
                continue;
            if (screen_x >= SCREEN_FB_WIDTH)
                break;

            int src_offset = row * surface->w + col;

            int pixel = surface->pixels[src_offset];

            // draw cursor in here + redraw_background in poll_events
            int cx = screen_x - relative_x;
            int cy = screen_y - relative_y;
            if (cx >= 0 && cy >= 0 && cx < CURSOR_W && cy < CURSOR_H) {
                int i = (cy * CURSOR_W + cx) * 4;
                uint8_t a = cursor[i + 3];
                if (a > 0) {
                    uint8_t r = cursor[i];
                    uint8_t g = cursor[i + 1];
                    uint8_t b = cursor[i + 2];
                    pixel = (r << 16) | (g << 8) | b;
                }
            }

            uint8_t b = (pixel >> 16) & 0xff;
            uint8_t g = (pixel >> 8) & 0xff;
            uint8_t r = pixel & 0xff;

            uint16_t rgb565 = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);

            fb_ptr[(row + screen_offset_y) * VRAM_STRIDE + (col + screen_offset_x)] = rgb565;
        }
    }
    // sceDisplayWaitVblankStart();
    // sceDisplaySetFrameBuf(fb, VRAM_STRIDE, PSP_DISPLAY_PIXEL_FORMAT_565, PSP_DISPLAY_SETBUF_NEXTFRAME);
}
void platform_update_surface(void) {
}
uint64_t rs2_now(void) {
    return sceKernelGetSystemTimeWide() / 1000;
}
void rs2_sleep(int ms) {
    sceKernelDelayThreadCB(ms * 1000);
}
#endif
